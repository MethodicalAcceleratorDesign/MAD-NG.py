--[=[
 o-----------------------------------------------------------------------------o
 |
 | Pymad module
 |
 | Methodical Accelerator Design - Copyright (c) 2016+
 | Support: http://cern.ch/mad  - mad at cern.ch
 | Authors: L. Deniau, laurent.deniau at cern.ch
 | Contrib: J. Gray, joshua.mark.gray@cern.ch
 |
 o-----------------------------------------------------------------------------o
 | You can redistribute this file and/or modify it under the terms of the GNU
 | General Public License GPLv3 (or later), as published by the Free Software
 | Foundation. This file is distributed in the hope that it will be useful, but
 | WITHOUT ANY WARRANTY OF ANY KIND. See http://gnu.org/licenses for details.
 o-----------------------------------------------------------------------------o

  Purpose:
  - Provide MAD minimal feature to communicate with parent Python process

 o-----------------------------------------------------------------------------o
]=]

-- locals ---------------------------------------------------------------------o

local ffi = require "ffi"
local _C, matrix, cmatrix, imatrix                    in MAD
local is_string, isy_matrix, get_metatable, is_number, is_table, has_metatable in MAD.typeid
local fprintf                                         in MAD.utility
local format                                          in string
local min, max                                        in math

local assert, tonumber = assert, tonumber

ffi.cdef [[
FILE *fdopen(int fd, const char *mode);
size_t fwrite(const void *restrict buffer, size_t size, size_t count, FILE *restrict stream);
size_t fread( void *restrict buffer, size_t size, size_t count, FILE *restrict stream );
void setbuf( FILE *restrict stream, char *restrict buffer );
int close(int fildes);
]]

local np_mat_elem_type = {
  [get_metatable(MAD.imatrix(1))] = "int32",
  [get_metatable(MAD. matrix(1))] = "float64",
  [get_metatable(MAD.cmatrix(1))] = "complex128",
}

local ctor_by_elemsize = {
  [ matrix(1):bytesize()] = matrix,
  [cmatrix(1):bytesize()] = cmatrix,
  [imatrix(1):bytesize()] = imatrix,
}

-- implementation -------------------------------------------------------------o

local pymad = MAD.object 'pymad' { dispdbgf = false }

local function dispdbg (str)
  io.write("***mad.send: '", str:sub(1, min(32,#str)))
  if #str > 32 then io.write("' .. '", str:sub(max(32,#str-32),-1)) end
  io.write("' ***\n")
end

local function send (self, str)
  assert(is_string(str), "invalid argument #2 (string expected)")
  if self.dispdbgf then dispdbg(str) end
  local strn = format("%010d", #str)
  _C.fwrite(strn, #strn, 1, self.__py_out)
  _C.fwrite(str , #str , 1, self.__py_out)
  return self
end

local function send_instruction_set (self, pycmd, data, data_size)
  local strn = format("%010d", data_size)
  if self.dispdbgf then
    dispdbg(pycmd .. " for " .. tostring(data).. " with ".. strn .. " bytes")
  end
  self:send(pycmd)
  _C.fwrite(strn, #strn, 1, self.__py_out)
  _C.fwrite(data, data_size, 1, self.__py_out)
end

local function send_mat (self, mat, name)
  -- assert(isy_matrix(mat), "invalid argument #2 (matrix expected)") -- not needed if exposed
  local mattypestr = np_mat_elem_type[get_metatable(mat)]
  local pycmd = name .. "=np.frombuffer(mad.rawRead(), dtype=np." .. mattypestr .. ").reshape("..mat.nrow..","..mat.ncol..")"
  send_instruction_set(self, pycmd, mat._dat, mat:bytesize())
end

local function send_str(self, str, name)
  local pycmd = name .. "=mad.rawRead().decode('utf-8')"
  send_instruction_set(self, pycmd, str, #str)
end

local function send_num(self, num, name)
  local mat = matrix(1):fill(num)
  local pycmd = name .. "=struct.unpack('d', mad.rawRead())[0]"
  send_instruction_set(self, pycmd, mat._dat, mat:bytesize())
end

local function send_data (self, data, name)
  if isy_matrix(data) then
    send_mat(self, data, name)
  elseif is_string(data) then 
    send_str(self, data, name)
  elseif is_number(data) then 
    send_num(self, data, name)
  elseif has_metatable(data) then
    self:send(name .. "=madObject('" .. name .. "',superClass)")
  elseif is_table(data) then
    self:send(name .. "=mad.readTable("..#data..")")
    for i, v in ipairs(data) do
      self:send_data(v, "tabledataval")
    end
  end
end

local function read_mat (self, nrow, ncol)
  local bytesize = tonumber(io.read(10))
  local mat = ctor_by_elemsize[bytesize / (nrow * ncol)](nrow, ncol)
  _C.fread(mat._dat, bytesize, 1, io.stdin)
  return mat
end

local function catch_err(err)
  print(err, "\n", debug.traceback())
end

local function open_pipe (self, py_out_fd, py_in_fd)
  self.__py_out_fd = py_out_fd
  self.__py_out = _C.fdopen(py_out_fd, "wb")
  _C.setbuf(self.__py_out, nil)
  while true do
    local strLength = tonumber(io.read(10))
    local input = io.read(strLength)
    local status, err = xpcall(load(input, nil, nil, self.env), catch_err)
  end
  return self
end

local function publish (self, env_)
  self.env = env_ or {}
  setmetatable(self.env, {__index = _G})
  self.env[self.name] = self
  return self
end

pymad:set_methods {
  send      = send,
  send_data = send_data,
  read_mat  = read_mat,
  publish   = publish,
  open_pipe = open_pipe,
} :set_readonly()

-- end ------------------------------------------------------------------------o
return { pymad = pymad }